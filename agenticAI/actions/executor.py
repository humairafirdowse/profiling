"""
Action execution engine.
"""
from typing import Any, Dict, Optional
from .action import Action, ActionType, ActionResult
from ..tools.base import ToolRegistry
from ..llm.base import LLMProvider


class ActionExecutor:
    """Executes actions generated by the agent"""
    
    def __init__(self, tool_registry: ToolRegistry, llm_provider: Optional[LLMProvider] = None):
        self.tool_registry = tool_registry
        self.llm_provider = llm_provider
        self.mcp_clients = {}  # MCP client registry
    
    async def execute(self, action: Action, workspace_path: str = ".") -> ActionResult:
        """
        Execute an action and return the result.
        
        Args:
            action: Action to execute
            workspace_path: Workspace path for context
        
        Returns:
            ActionResult
        """
        try:
            if action.type == ActionType.TOOL_CALL:
                return await self._execute_tool_call(action, workspace_path)
            elif action.type == ActionType.LLM_GENERATE:
                return await self._execute_llm_generate(action)
            elif action.type == ActionType.MCP_REQUEST:
                return await self._execute_mcp_request(action)
            elif action.type == ActionType.FINISH:
                return ActionResult.success_result("Agent finished", {"action": "finish"})
            else:
                return ActionResult.error_result(f"Unsupported action type: {action.type}")
        except Exception as e:
            return ActionResult.error_result(f"Action execution failed: {str(e)}")
    
    async def _execute_tool_call(self, action: Action, workspace_path: str) -> ActionResult:
        """Execute a tool call action"""
        tool = self.tool_registry.get(action.name)
        if not tool:
            return ActionResult.error_result(f"Tool '{action.name}' not found")
        
        # Add workspace_path to parameters
        params = {**action.parameters, "workspace_path": workspace_path}
        
        result = await self.tool_registry.execute_tool(action.name, **params)
        
        if result.get("success"):
            return ActionResult.success_result(
                result.get("result"),
                {"tool": action.name, **result}
            )
        else:
            return ActionResult.error_result(
                result.get("error", "Tool execution failed"),
                {"tool": action.name}
            )
    
    async def _execute_llm_generate(self, action: Action) -> ActionResult:
        """Execute LLM generation action"""
        if not self.llm_provider:
            return ActionResult.error_result("LLM provider not available")
        
        content = action.parameters.get("content", "")
        system_prompt = action.parameters.get("system_prompt")
        
        response = await self.llm_provider.generate(
            prompt=content,
            system_prompt=system_prompt
        )
        
        return ActionResult.success_result(
            response.content,
            {"model": response.model, "usage": response.usage}
        )
    
    async def _execute_mcp_request(self, action: Action) -> ActionResult:
        """Execute an MCP request"""
        # MCP implementation would go here
        # This is a placeholder
        method = action.name
        params = action.parameters
        
        # In a real implementation, you'd:
        # 1. Get or create MCP client
        # 2. Send request via MCP protocol
        # 3. Return response
        
        return ActionResult.error_result(
            "MCP requests not yet fully implemented",
            {"method": method, "params": params}
        )
    
    def register_mcp_client(self, name: str, client: Any):
        """Register an MCP client"""
        self.mcp_clients[name] = client


